#load libraries
library(affy);
# Setting up packages
setRepositories(graphics = F, c(1,2,3,4,5))
install.packages(c('affy','drosophila2cdf'))
#load libraries
library(affy);
#load Affymetrix CEL files
data <- ReadAffy(); #loading CEL files for wild-type and mutant samples GFP +ve and -ve (16 chips)
setwd("~/Desktop/lecture9/microarray")
#load Affymetrix CEL files
data <- ReadAffy(); #loading CEL files for wild-type and mutant samples GFP +ve and -ve (16 chips)
pData(data)$condition <- as.factor(c(rep('wt',8),rep('mut',8)));
pData(data)$gfp <- as.factor(rep(c('p','n'),8));
pData(data)$sample <- as.factor(sort(rep(seq(1,8),2)));
#view the updated phenotype data
pData(data);
#now lets normalise the data
norm <- rma(data); # RMA - the Robust Multi-Chip Average - returns expression in log2
#and extract the expression matrix
exprs <- exprs(norm);
#PART THREE - Principal Component Analysis (PCA)
pca <- prcomp(t(exprs)); # Note, we are doing PCA by chip i.e. trying to see where the variation is between the chips
#look at where the variation is across the Principal Components
summary(pca);
#extract the principal components
pcs <- data.frame(pca$x);
#add in the annotation data by merging (just for the first 2 principal components)
pcs <- merge(pcs[,1:2],pData(data),by=0);
#plot the first two principal components
library(lattice);
#plot by condition
xyplot(PC2~PC1,pcs,group=condition,auto.key=T);
#plot by gfp status
xyplot(PC2~PC1,pcs,group=gfp,auto.key=T);
#plot by sample
xyplot(PC2~PC1,pcs,group=sample,auto.key=T);
#PART FOUR - Differential Expression Calling
#load limma a package for calling differntially expressed genes
library(limma);
install.packages(c('affy','drosophila2cdf','limma','topGO'))
install.packages(c("affy", "drosophila2cdf", "limma", "topGO"))
install.packages(c("affy", "drosophila2cdf", "limma", "topGO"))
install.packages(c("affy", "drosophila2cdf", "limma", "topGO"))
install.packages(c("affy", "drosophila2cdf", "limma", "topGO"))
#PART FOUR - Differential Expression Calling
#load limma a package for calling differntially expressed genes
library(limma);
plotMA(data)
plotMA(exprs)
#load the Bioconductor annotation file for the Drosophila_2 chips
library(drosophila2.db);
install.packages(c('affy','drosophila2cdf','limma','topGO','drosophila2.db'))
install.packages(c("affy", "drosophila2cdf", "limma", "topGO", "drosophila2.db"))
#load the Bioconductor annotation file for the Drosophila_2 chips
library(drosophila2.db);
#convert the expresison matrix from log2 scale to base 10
exprs <- data.frame(2^exprs); # we're just extracting the expression slot from the ExpressionSet object, convert to base10
#add group to the annotation data
d <- data.frame(pData(data));
d$group<-interaction(d$gfp,d$sample,sep='');
#rename columns to make easier to identify
colnames(exprs) <- d$group[match(row.names(d),colnames(exprs))];
#these variables can be exported to the environment so that they can be referred to directly
attach(exprs);
#create an enrichment matrix by dividing GFP+ signal by GFP- signal
enrich <- data.frame(s1=p1/n1,s2=p2/n2,s3=p3/n3,s4=p4/n4,s5=p5/n5,s6=p6/n6,s7=p7/n7,s8=p8/n8,row.names=row.names(exprs));
#set up the 'levels' matrix (this shows the groupings for contrasts)
enrich_design <- table(data.frame(row.names=colnames(enrich),unique(d[,1:2])));
#look at it
enrich_design;
#set up the contrast matrix (what we are comparing) - note 'wt-mut'
cont.matrix <- makeContrasts(wt-mut,levels=enrich_design);
#look at it
cont.matrix;
#fit the linear model
fit <- lmFit(enrich, enrich_design);
#calculate the fit coefficients and error for the comparison(s)
fit2 <- contrasts.fit(fit, cont.matrix);
#calculate t-statistics and log-odds of differential expression using emperical Bayes approach
fit2 <- eBayes(fit2);
#have a quick look at the result
topTable(fit2,n=10,sort.by='logFC',p=0.01,adjust='fdr');
#get the differentially expressed genes fdr=1%
diffexp <- topTable(fit2,adjust="fdr",sort.by='logFC',n=1000000000,p=0.01);
#bring in the gene names
diffexp_final <- merge(diffexp_top,toTable(drosophila2SYMBOL[rownames(diffexp_top)]),by.x=0,by.y='probe_id',sort=F,all.x=T);
#reformat to make the results simpler to view
diffexp_top <- data.frame(diffexp[,c(1,2)],fdr=diffexp[,6],fc=diffexp[,2]);
#bring in the gene names
diffexp_final <- merge(diffexp_top,toTable(drosophila2SYMBOL[rownames(diffexp_top)]),by.x=0,by.y='probe_id',sort=F,all.x=T);
#look at the top10
diffexp_final[1:10,];
#PART FIVE - Functional Annotation
#Using  package to look for functional enrichment in gene lists
library(topGO);
geneList <- fit2$p.value[,1];
names(geneList) <- as.factor(fit2$genes[,1]);
names(geneList) <- as.factor(rownames(fit2));
topDiffGenes <- function(x){
return(x<=0.01)
}
#now set up the Drosophila GO
library(drosophila2.db);
#create the GOData object that contains all of the gene association information for background and your own gene list
sampleGOdata <- new("topGOdata",description = "Simple session", ontology = "BP",allGenes = geneList, geneSel = topDiffGenes,nodeSize = 10,  annot = annFUN.db, affyLib = "drosophila2.db")
#perform a Fisher test to look for statistically significant enrichment of terms
resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
#use a Kolmogorov–Smirnov test instead
resultKS <- runTest(sampleGOdata, algorithm = "classic", statistic = "ks")
#apply KS test, with more conservative outcome 'elim'
resultKS.elim <- runTest(sampleGOdata, algorithm = "elim", statistic = "ks")
#display all the tests together
allRes <- GenTable(sampleGOdata, classicFisher = resultFisher, classicKS = resultKS, elimKS = resultKS.elim, orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 30)
allRes
#PART SIX - Clustering
library(cluster)
#check to see that gthe chips segregate by genotype
cl <- kmeans(t(enrich),2);
#cluster the top 100 differentially expressed genes
cl_group <- diffexp_final[1:100,]
colnames(cl_group)[1] <- 'ID'
#get the ids
ids <- cl_group$ID;
#extract only those expression values
cl_enrich <- enrich[ids,];
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order);
cl_enrich
cl_group
#get the ids
ids <- cl_group$symbol;
#extract only those expression values
cl_enrich <- enrich[symbol,];
cl_group
#get the ids
ids <- cl_group$ID;
#extract only those expression values
cl_enrich <- enrich[ids,];
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
cl_enrich
rownames(cl_enrich) %in% rownames(cl_group)
cl_group
rownames(cl_enrich) %in% cl_group$ID
which(rownames(cl_enrich) %in% cl_group$ID)
rownames(cl_enrich) <- cl_enrich[which(rownames(cl_enrich) %in% cl_group$ID),'symbol')
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order,);
rownames(cl_enrich) <- cl_enrich[which(rownames(cl_enrich) %in% cl_group$ID),'symbol')
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order,);
rownames(cl_enrich) <- cl_enrich[which(rownames(cl_enrich) %in% cl_group$ID),'symbol')]
rownames(cl_enrich) <- cl_enrich[which(rownames(cl_enrich) %in% cl_group$ID),'symbol']
cl_enrich
rownames(cl_enrich) <- cl_group[which(rownames(cl_enrich) %in% cl_group$ID),'symbol']
cl_group
cl_enrich
rownames(cl_enrich) <-
cl_group[which(rownames(cl_enrich) %in% cl_group$ID),'symbol']
rownames(cl_enrich) <-
which(rownames(cl_enrich) %in% cl_group$ID)
#cluster the top 100 differentially expressed genes
cl_group <- diffexp_final[1:100,]
colnames(cl_group)[1] <- 'ID'
#get the ids
ids <- cl_group$ID;
#extract only those expression values
cl_enrich <- enrich[ids,];
rownames(cl_enrich) <-
which(rownames(cl_enrich) %in% cl_group$ID)
rownames(cl_enrich) <-
which(rownames(cl_enrich) %in% cl_group$ID)
rownames(cl_enrich) <-
rownames(cl_enrich) %in% cl_group$ID
rownames(cl_enrich)
#extract only those expression values
cl_enrich <- enrich[ids,];
rownames(cl_enrich)
rownames(cl_enrich) %in% cl_group$ID
which(rownames(cl_enrich) %in% cl_group$ID)
cl_group[which(rownames(cl_enrich) %in% cl_group$ID),]
cl_group[which(rownames(cl_enrich) %in% cl_group$ID),'symbol']
rownames(cl_enrich) <- cl_group[which(rownames(cl_enrich) %in% cl_group$ID),'symbol']
names <- cl_group[which(rownames(cl_enrich) %in% cl_group$ID),'symbol']
names
names[4]
names[4] <- 'toy_'
rownames(cl_enrich) <- names
cl <- kmeans(t(enrich),2);
#cluster the top 100 differentially expressed genes
cl_group <- diffexp_final[1:100,]
colnames(cl_group)[1] <- 'ID'
#get the ids
ids <- cl_group$ID;
#extract only those expression values
cl_enrich <- enrich[ids,];
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order,);
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order,);
setwd("~/Desktop/lecture9/lecture9")
setRepositories(graphics = F,c(1,2,3,4,5))
install.packages('DESeq2')
# Load the DESeq2 library into R.
library("DESeq2")
# Load "pasilla_gene_counts.tsv", which contains per-gene counts of mapped reads
# for each sample in the study:
#  Brooks et al., "Conservation of an RNA regulatory map between Drosophila and
#  mammals", Genome Research (2011).
# Note that if the "pasilla_gene_counts.tsv" file is in a different directory to
# where you are running R, you'll need to specify the relative path to the file
# within the following statement.
pasillaCounts <- read.csv("pasilla_gene_counts.tsv", sep="\t", row.names="gene_id")
setwd("~/Desktop/lecture9/lecture9/rnaseq")
# Load "pasilla_gene_counts.tsv", which contains per-gene counts of mapped reads
# for each sample in the study:
#  Brooks et al., "Conservation of an RNA regulatory map between Drosophila and
#  mammals", Genome Research (2011).
# Note that if the "pasilla_gene_counts.tsv" file is in a different directory to
# where you are running R, you'll need to specify the relative path to the file
# within the following statement.
pasillaCounts <- read.csv("pasilla_gene_counts.tsv", sep="\t", row.names="gene_id")
pasillaCounts <- as.matrix(pasillaCounts)
# Examine the per-gene read counts.
head(pasillaCounts)
# In addition to count data, we'll need to load a file containing metadata
# describing the experimental samples
pasillaSamples <- read.csv("pasilla_sample_data.tsv", sep="\t", row.names="sample")
# Examine the sample metadata
pasillaSamples
# Construct a vector of "TRUE" or "FALSE" values according as each sample is from
# a single- or paired-end library.
pairedSamples <- pasillaSamples$type == "paired-end"
# Then use that vector to extract just the counts for the paired-end samples, and
# reassign this data to the "pasillaCounts" variable.
pasillaCounts <- pasillaCounts[ , pairedSamples ]
# Now the counts table only contains per-gene read counts for the paired-end
# samples.
head(pasillaCounts)
# We'll do the same for the sample metadata (n.b. here we're selecting rows;
# for the counts we were selecting columns)
pasillaSamples <- pasillaSamples[ pairedSamples, ]
# As it stands, the experimental conditions are ordered the wrong way round because
# DESeq2 chooses the base condition by alphabetical order (this just means that fold
# changes for gene expression won't be the way round that we'd naturally expect, that
# is, "treated" vs "untreated").
pasillaSamples$condition
# But we can easily reorder so that "untreated" is the base condition - and DESeq2
# will then report differential expression in the "treated" condition relative
# to this.
pasillaSamples$condition <- relevel(pasillaSamples$condition, ref="untreated")
# Now the conditions are the right way round.
pasillaSamples$condition
dds <- DESeqDataSetFromMatrix(
countData=pasillaCounts, colData=pasillaSamples, design=~condition)
# Examining this object gives some summary information on the samples and
# number of genes.
dds
# different total numbers of reads may be produced in different sequencing runs
# (i.e. the samples are sequenced to different "depths" of read coverage), genes
# which are *not* differentially expressed may nevertheless have very different
# counts across samples. DESeq2 assumes that most genes are not differentially
# expressed (which is *usually* - but not always! - a sensible assumption), and
# then calculates a per-sample "size factor" to be applied to the counts of each
# sample (it divides each count by the size factor). This brings the counts for
# each sample onto a common scale so that comparisons can be made between them.
# (n.b. there are many other ways in which sample counts could potentially be
# normalised, and this is still an active area of research.)
dds <- estimateSizeFactors(dds)
# DESeq has calculated, for example, that the counts in the "treated3" sample are
# considerably larger than all the other samples, and that those in the
# "untreated3" sample are considerably smaller.
sizeFactors(dds)
# ...and normalised counts.
head(counts(dds, normalized=TRUE))
# squared). Dispersion can be understood as follows - if a gene's expression varies
# from replicate to replicate by 20%, its dispersion is 0.2*0.2=0.04.
# The function estimateDispersions() performs three steps:
#   (i) it estimates a dispersion value for each gene (which value may itself have
#   a large sampling variance due to the limited number of samples it is calculated
#   from),
#   (ii) it fits a curve through these estimates,
#   (iii) for each gene it "shrinks" the noisy gene-wise dispersion estimates towards
#   the consensus represented by the fitted curve (though outliers, with large
#   dispersion estimates, are left unchanged)
dds <- estimateDispersions(dds)
# We can view the per-gene dispersion estimates and the fitted curve using the
# plotDispEsts() function. Black dots are the original gene-wise dispersion estimates,
# the red line is the fitted curve, and the blue dots are the final "shrunken"
# dispersion estimates. Black dots surrounded by blue circles are the outliers,
# whose dispersion estimate was not altered.
plotDispEsts(dds)
# ### Part 9 - Call Differentially Expressed Genes
# We now have a dispersion estimate for each gene. DESeq2 is now in a position
# to perform tests, for each gene, using the negative binomial distribution to
# see if the counts in the two experimental conditions come from distributions
# with different means.
res <- results(nbinomWaldTest(dds, betaPrior=TRUE))
head(res)
# Make a scatter plot of logarithmic fold changes (y-axis) versus the mean of
# normalised counts (x-axis). Differentially expressed genes are coloured red.
plotMA(res, ylim=c(-2,2))
# ### Part 10 - Examine Differentially Expressed Genes
# We'll remove genes for which DESeq2 did not perform a full calculation.
# This includes, for example, genes with low mean counts that DESeq2 had
# determined were unlikely to be called as differentially expressed. These
# genes are indicated by a value of "NA" in the "padj" column.
res <- res[ !is.na(res$padj), ]
# Select genes called as differentially expressed with the False Discovery Rate
# controlled at 10% - that is, at most 10% of the genes called as differentially
# expressed will be false positives.
resSig <- res[ res$padj < 0.1, ]
# Order the significant genes by p-value - i.e. by their likelihood of being
# differentially expressed.
head(resSig[ order(resSig$pvalue), ])
# Examine the most strongly down-regulated of the significant genes.
head(resSig[ order(resSig$log2FoldChange, -resSig$baseMean), ])
# Examine the most strongly up-regulated of the significant genes.
head(resSig[ order(-resSig$log2FoldChange, -resSig$baseMean), ])
# ### Part 11 - What about Pasilla?
# Select pasilla (which has FlyBase gene ID "FBgn0261552") from the results table.
# Is it differentially expressed (let's hope so!)?
resSig["FBgn0261552", ]
