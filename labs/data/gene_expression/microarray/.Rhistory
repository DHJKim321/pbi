library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels,pch=pData(data)$condition);
boxplot(data,las=2,col=myCondcol[pData(data)$condition],ylab='Expression',names=myLabels);
# show a raw image of an individual microarray chip (!)
image(data[,1]);
#examine the slots
data@cdfName; #get the chip platform name
data@phenoData; #get the experimental data
#what's an AnnotatedDataFrame
?AnnotatedDataFrame;
#lets annotate on the experimental information
pData(data)$condition <- as.factor(c(rep('wt',8),rep('mut',8)));
pData(data)$gfp <- as.factor(rep(c('p','n'),8));
pData(data)$sample <- as.factor(sort(rep(seq(1,8),2)));
#view the updated phenotype data
pData(data)
#now lets normalise the data
norm <- rma(data); # RMA - the Robust Multi-Chip Average - returns expression in log2
#and extract the expression matrix
exprs <- exprs(norm);
pca <- prcomp(t(exprs)); # Note, we are doing PCA by chip i.e. trying to see where the variation is between the chips
#look at where the variation is across the Principal Components
summary(pca);
#extract the principal components
pcs <- data.frame(pca$x);
#add in the annotation data by merging (just for the first 2 principal components)
pcs <- merge(pcs[,1:2],pData(data),by=0);
#plot the first two principal components
library(ggplot2);
#plot by condition
ggplot(pcs,aes(PC1,PC2,colour=condition))+geom_point()+theme_bw()+scale_colour_manual(values=c('red','gray'));
#plot by gfp status
ggplot(pcs,aes(PC1,PC2,colour=gfp))+geom_point()+theme_bw()+scale_colour_manual(values=c('gray','green'));
#load limma a package for calling differntially expressed genes
library(limma);
setRepositories()
install.packages('limma')
#load limma a package for calling differntially expressed genes
library(limma);
#load the Bioconductor annotation file for the Drosophila_2 chips
library(drosophila2.db);
install.packages(drosophila2.db);
install.packages("drosophila2.db");
#load limma a package for calling differntially expressed genes
library(limma);
#load the Bioconductor annotation file for the Drosophila_2 chips
library(drosophila2.db);
#convert the expresison matrix from log2 scale to base 10
exprs <- data.frame(2^exprs); # we're just extracting the expression slot from the ExpressionSet object, convert to base10
#add group to the annotation data
d <- data.frame(pData(data));
d$group<-interaction(d$gfp,d$sample,sep='');
#rename columns to make easier to identify
colnames(exprs) <- d$group[match(row.names(d),colnames(exprs))];
#these variables can be exported to the environment so that they can be referred to directly
attach(exprs);
#create an enrichment matrix by dividing GFP+ signal by GFP- signal
enrich <- data.frame(s1=p1/n1,s2=p2/n2,s3=p3/n3,s4=p4/n4,s5=p5/n5,s6=p6/n6,s7=p7/n7,s8=p8/n8,row.names=row.names(exprs));
#set up the 'levels' matrix (this shows the groupings for contrasts)
enrich_design <- table(data.frame(row.names=colnames(enrich),unique(d[,1:2])));
#look at it
enrich_design;
#set up the contrast matrix (what we are comparing) - note 'wt-mut'
cont.matrix <- makeContrasts(wt-mut,levels=enrich_design);
#look at it
cont.matrix;
#fit the linear model
fit <- lmFit(enrich, enrich_design);
#calculate the fit coefficients and error for the comparison(s)
fit2 <- contrasts.fit(fit, cont.matrix);
#calculate t-statistics and log-odds of differential expression using emperical Bayes approach
fit2 <- eBayes(fit2);
#have a quick look at the result
topTable(fit2,n=10,sort.by='logFC',p=0.01,adjust='fdr');
#get the differentially expressed genes fdr=1%
diffexp <- topTable(fit2,adjust="fdr",sort.by='logFC',n=1000000000,p=0.01);
#reformat to make the results simpler to view
diffexp_top <- data.frame(diffexp[,c(1,2)],fdr=diffexp[,6],fc=diffexp[,2]);
#bring in the gene names
diffexp_final <- merge(diffexp_top,toTable(drosophila2SYMBOL[rownames(diffexp_top)]),by.x=0,by.y='probe_id',sort=F,all.x=T);
#look at the top10
diffexp_final[1:10,]
#Using  package to look for functional enrichment in gene lists
library(topGO);
install.packages("topGO");
#Using  package to look for functional enrichment in gene lists
library(topGO);
geneList <- fit2$p.value[,1];
names(geneList) <- as.factor(fit2$genes[,1]);
names(geneList) <- as.factor(rownames(fit2));
topDiffGenes <- function(x){
return(x<=0.01)
}
#now set up the Drosophila GO
library(drosophila2.db);
#create the GOData object that contains all of the gene association information for background and your own gene list
sampleGOdata <- new("topGOdata",description = "Simple session", ontology = "BP",allGenes = geneList, geneSel = topDiffGenes,nodeSize = 10,  annot = annFUN.db, affyLib = "drosophila2.db")
#perform a Fisher test to look for statistically significant enrichment of terms
resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
#use a Kolmogorov–Smirnov test instead
resultKS <- runTest(sampleGOdata, algorithm = "classic", statistic = "ks")
#apply KS test, with more conservative outcome 'elim'
resultKS.elim <- runTest(sampleGOdata, algorithm = "elim", statistic = "ks")
#display all the tests together
allRes <- GenTable(sampleGOdata, classicFisher = resultFisher, classicKS = resultKS, elimKS = resultKS.elim, orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 30)
print(allRes)
library(cluster)
#check to see that gthe chips segregate by genotype
cl <- kmeans(t(enrich),2);
#cluster the top 100 differentially expressed genes
cl_group <- diffexp_final[1:100,]
colnames(cl_group)[1] <- 'ID'
#get the ids
ids <- cl_group$ID;
#extract only those expression values
cl_enrich <- enrich[ids,];
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
myLabels = unique(paste(pData(data)$condition,pData(data)$sample,sep="-"))
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order,labCol = myLabels)
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
myGFPcol[pData(data)$gfp]
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
myLabels
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myCondcol[pData(data)$condition],ylab='Expression',names=myLabels);
#load the Affy package that's specifically designed for Affymetrix microarray data
library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myCondcol[pData(data)$condition],ylab='Expression',names=myLabels);
# show a raw image of an individual microarray chip (!)
image(data[,1]);
#examine the slots
data@cdfName; #get the chip platform name
data@phenoData; #get the experimental data
#what's an AnnotatedDataFrame
?AnnotatedDataFrame;
#lets annotate on the experimental information
pData(data)$condition <- as.factor(c(rep('wt',8),rep('mut',8)));
pData(data)$gfp <- as.factor(rep(c('p','n'),8));
pData(data)$sample <- as.factor(sort(rep(seq(1,8),2)));
#view the updated phenotype data
pData(data)
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
#load the Affy package that's specifically designed for Affymetrix microarray data
library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels)
col
myGFPcol[pData(data)$gfp]
#load the Affy package that's specifically designed for Affymetrix microarray data
library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels)
myGFPcol[pData(data)$gfp]
```{R part1}
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels)
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels)
#load the Affy package that's specifically designed for Affymetrix microarray data
library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
myLabels
#load the Affy package that's specifically designed for Affymetrix microarray data
library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myCondcol[pData(data)$condition],ylab='Expression',names=myLabels);
# show a raw image of an individual microarray chip (!)
image(data[,1]);
#examine the slots
data@cdfName; #get the chip platform name
data@phenoData; #get the experimental data
#what's an AnnotatedDataFrame
?AnnotatedDataFrame;
#lets annotate on the experimental information
pData(data)$condition <- as.factor(c(rep('wt',8),rep('mut',8)));
pData(data)$gfp <- as.factor(rep(c('p','n'),8));
pData(data)$sample <- as.factor(sort(rep(seq(1,8),2)));
#view the updated phenotype data
pData(data)
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
myLabels
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myCondcol[pData(data)$condition],ylab='Expression',names=myLabels);
##setRepositories(graphics = F, c(1,2,3,4,5))
##install.packages(c('affy','drosophila2cdf','limma','topGO','drosophila2.db'))
#load the Affy package that's specifically designed for Affymetrix microarray data
library(affy);
#set working directory
setwd('./')
# load Affymetrix CEL files - these are the raw output files from the scanning machine
# we have data from wild-type and mutant samples either GFP +ve or -ve (16 chips)
data <- ReadAffy();
#find out a bit about the object
class(data);
#what's an AffyBatch object
?AffyBatch
#some useful methods in Affy
library(RColorBrewer);
myGFPcol <- c('gray','green')
myCondcol <- c('red','gray')
# show the first 10 probe expression data for perfect match oligos
probes(data,which='pm')[1:10,];
# show a summary box-whisker plot for each chip
myLabels <- paste(pData(data)$sample,pData(data)$condition,pData(data)$gfp,sep='_');
boxplot(data,las=2,col=myGFPcol[pData(data)$gfp],ylab='Expression',names=myLabels);
boxplot(data,las=2,col=myCondcol[pData(data)$condition],ylab='Expression',names=myLabels);
# show a raw image of an individual microarray chip (!)
image(data[,1]);
#examine the slots
data@cdfName; #get the chip platform name
data@phenoData; #get the experimental data
#what's an AnnotatedDataFrame
?AnnotatedDataFrame;
#lets annotate on the experimental information
pData(data)$condition <- as.factor(c(rep('wt',8),rep('mut',8)));
pData(data)$gfp <- as.factor(rep(c('p','n'),8));
pData(data)$sample <- as.factor(sort(rep(seq(1,8),2)));
#view the updated phenotype data
pData(data)
#now lets normalise the data
norm <- rma(data); # RMA - the Robust Multi-Chip Average - returns expression in log2
#and extract the expression matrix
exprs <- exprs(norm);
pca <- prcomp(t(exprs)); # Note, we are doing PCA by chip i.e. trying to see where the variation is between the chips
#look at where the variation is across the Principal Components
summary(pca);
#extract the principal components
pcs <- data.frame(pca$x);
#add in the annotation data by merging (just for the first 2 principal components)
pcs <- merge(pcs[,1:2],pData(data),by=0);
#plot the first two principal components
library(ggplot2);
#plot by condition
ggplot(pcs,aes(PC1,PC2,colour=condition))+geom_point()+theme_bw()+scale_colour_manual(values=c('red','gray'));
#plot by gfp status
ggplot(pcs,aes(PC1,PC2,colour=gfp))+geom_point()+theme_bw()+scale_colour_manual(values=c('gray','green'));
#load limma a package for calling differntially expressed genes
library(limma);
#load the Bioconductor annotation file for the Drosophila_2 chips
library(drosophila2.db);
#convert the expresison matrix from log2 scale to base 10
exprs <- data.frame(2^exprs); # we're just extracting the expression slot from the ExpressionSet object, convert to base10
#add group to the annotation data
d <- data.frame(pData(data));
d$group<-interaction(d$gfp,d$sample,sep='');
#rename columns to make easier to identify
colnames(exprs) <- d$group[match(row.names(d),colnames(exprs))];
#these variables can be exported to the environment so that they can be referred to directly
attach(exprs);
#create an enrichment matrix by dividing GFP+ signal by GFP- signal
enrich <- data.frame(s1=p1/n1,s2=p2/n2,s3=p3/n3,s4=p4/n4,s5=p5/n5,s6=p6/n6,s7=p7/n7,s8=p8/n8,row.names=row.names(exprs));
#set up the 'levels' matrix (this shows the groupings for contrasts)
enrich_design <- table(data.frame(row.names=colnames(enrich),unique(d[,1:2])));
#look at it
enrich_design;
#set up the contrast matrix (what we are comparing) - note 'wt-mut'
cont.matrix <- makeContrasts(wt-mut,levels=enrich_design);
#look at it
cont.matrix;
#fit the linear model
fit <- lmFit(enrich, enrich_design);
#calculate the fit coefficients and error for the comparison(s)
fit2 <- contrasts.fit(fit, cont.matrix);
#calculate t-statistics and log-odds of differential expression using emperical Bayes approach
fit2 <- eBayes(fit2);
#have a quick look at the result
topTable(fit2,n=10,sort.by='logFC',p=0.01,adjust='fdr');
#get the differentially expressed genes fdr=1%
diffexp <- topTable(fit2,adjust="fdr",sort.by='logFC',n=1000000000,p=0.01);
#reformat to make the results simpler to view
diffexp_top <- data.frame(diffexp[,c(1,2)],fdr=diffexp[,6],fc=diffexp[,2]);
#bring in the gene names
diffexp_final <- merge(diffexp_top,toTable(drosophila2SYMBOL[rownames(diffexp_top)]),by.x=0,by.y='probe_id',sort=F,all.x=T);
#look at the top10
diffexp_final[1:10,]
#Using  package to look for functional enrichment in gene lists
library(topGO);
geneList <- fit2$p.value[,1];
names(geneList) <- as.factor(fit2$genes[,1]);
names(geneList) <- as.factor(rownames(fit2));
topDiffGenes <- function(x){
return(x<=0.01)
}
#now set up the Drosophila GO
library(drosophila2.db);
#create the GOData object that contains all of the gene association information for background and your own gene list
sampleGOdata <- new("topGOdata",description = "Simple session", ontology = "BP",allGenes = geneList, geneSel = topDiffGenes,nodeSize = 10,  annot = annFUN.db, affyLib = "drosophila2.db")
#perform a Fisher test to look for statistically significant enrichment of terms
resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
#use a Kolmogorov–Smirnov test instead
resultKS <- runTest(sampleGOdata, algorithm = "classic", statistic = "ks")
#apply KS test, with more conservative outcome 'elim'
resultKS.elim <- runTest(sampleGOdata, algorithm = "elim", statistic = "ks")
#display all the tests together
allRes <- GenTable(sampleGOdata, classicFisher = resultFisher, classicKS = resultKS, elimKS = resultKS.elim, orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 30)
print(allRes)
library(cluster)
#check to see that gthe chips segregate by genotype
cl <- kmeans(t(enrich),2);
#cluster the top 100 differentially expressed genes
cl_group <- diffexp_final[1:100,]
colnames(cl_group)[1] <- 'ID'
#get the ids
ids <- cl_group$ID;
#extract only those expression values
cl_enrich <- enrich[ids,];
#use hierarchical clustering to partition the differentially expressed genes
hc <- hclust(dist(cl_enrich),method='complete');
myLabels = unique(paste(pData(data)$condition,pData(data)$sample,sep="-"))
#show the expression groupings in a heatmap
heatmap(as.matrix(cl_enrich),Rowv=hc$order,labCol = myLabels)
install.packages('DESeq2')
setRepositories()
install.packages('DESeq2')
setRepositories(graphics = F,c(1,2,3,4,5))
install.packages('DESeq2')
setwd('./')
pasillaCounts <- read.csv("pasilla_gene_counts.tsv", sep="\t", row.names="gene_id")
pasillaCounts <- as.matrix(pasillaCounts)
# Examine the per-gene read counts.
head(pasillaCounts)
# In addition to count data, we'll need to load a file containing metadata
pasillaSamples <- read.csv("pasilla_sample_data.tsv", sep="\t", row.names="sample")
# Examine the sample metadata
pasillaSamples
# Construct a vector of "TRUE" or "FALSE" values according as each sample is from
# a single- or paired-end library.
pairedSamples <- pasillaSamples$type == "paired-end"
# Then use that vector to extract just the counts for the paired-end samples, and
# reassign this data to the "pasillaCounts" variable.
pasillaCounts <- pasillaCounts[ , pairedSamples ]
# Now the counts table only contains per-gene read counts for the paired-end
# samples.
head(pasillaCounts)
# We'll do the same for the sample metadata (n.b. here we're selecting rows;
# for the counts we were selecting columns)
pasillaSamples <- pasillaSamples[ pairedSamples, ]
# As it stands, the experimental conditions are ordered the wrong way round because DESeq2 chooses the base condition by alphabetical order (this just means that fold
# changes for gene expression won't be the way round that we'd naturally expect, that is, "untreated" vs "treated"). But we can easily reorder so that "untreated" is the base condition - and DESeq2 will then report differential expression in the "treated" condition relative to this.
pasillaSamples$condition <- relevel(factor(pasillaSamples$condition,order=FALSE), ref="untreated")
# Now the conditions are the right way round.
pasillaSamples$condition
library(DESeq2)
# We can now create a "DESeqDataSet" object, encapsulating all the information we need to perform a differential expression analysis.
# Note that we also supply a design formula, expressing in what way we expect the counts for each gene to depend on the variables in "pasillaSamples".
# In this simple example, we just expect the counts to depend on whether the samples were untreated or treated (i.e. on the "condition" variable)
dds <- DESeqDataSetFromMatrix(
countData=pasillaCounts, colData=pasillaSamples, design=~condition)
# Examining this object gives some summary information on the samples and number of genes.
dds
# Now we can finally start to analyse the data. At this point, we'd normally use the function "DESeq", which wraps all the standard differential expression
# analysis steps into a single call. However, here we'll execute some of the steps separately, so as to examine in a little more detail.
# The first thing we have to do is normalise counts across the samples. Because different total numbers of reads may be produced in different sequencing runs
# (i.e. the samples are sequenced to different "depths" of read coverage), genes which are *not* differentially expressed may nevertheless have very different
# counts across samples. DESeq2 assumes that most genes are not differentially expressed (which is *usually* - but not always! - a sensible assumption), and
# then calculates a per-sample "size factor" to be applied to the counts of each sample (it divides each count by the size factor). This brings the counts for
# each sample onto a common scale so that comparisons can be made between them.
dds <- estimateSizeFactors(dds)
# DESeq has calculated, for example, that the counts in the "treated3" sample are considerably larger than all the other samples, and that those in the
# "untreated3" sample are considerably smaller.
sizeFactors(dds)
# We can see the difference the size factors make by examining the raw...
head(counts(dds))
# ...and normalised counts.
head(counts(dds, normalized=TRUE))
# DESeq2's statistical model relies on understanding the relationship between the gene count data's variance and its mean. The next step estimates the relationship
# between the mean normalised counts and their "dispersion" (that is, the squared coefficient of variation = the standard deviation divided by the mean, all
# squared). Dispersion can be understood as follows - if a gene's expression varies from replicate to replicate by 20%, its dispersion is 0.2*0.2=0.04.
# The function estimateDispersions() performs three steps:
# - (i) it estimates a dispersion value for each gene (which value may itself have a large sampling variance due to the limited number of samples it is calculated from)
# - (ii) it fits a curve through these estimates,
# - (iii) for each gene it "shrinks" the noisy gene-wise dispersion estimates towards the consensus represented by the fitted curve (though outliers, with large dispersion estimates, are left unchanged
dds <- estimateDispersions(dds)
# We can view the per-gene dispersion estimates and the fitted curve using the plotDispEsts() function. Black dots are the original gene-wise dispersion estimates,
# the red line is the fitted curve, and the blue dots are the final "shrunken" dispersion estimates. Black dots surrounded by blue circles are the outliers whose dispersion estimate was not altered.
plotDispEsts(dds)
# We now have a dispersion estimate for each gene. DESeq2 is now in a position
# to perform tests, for each gene, using the negative binomial distribution to
# see if the counts in the two experimental conditions come from distributions
# with different means.
res <- results(nbinomWaldTest(dds, betaPrior=TRUE))
head(res)
# Make a scatter plot of logarithmic fold changes (y-axis) versus the mean of
# normalised counts (x-axis). Differentially expressed genes are coloured red.
plotMA(res, ylim=c(-2,2))
# We'll remove genes for which DESeq2 did not perform a full calculation.
# This includes, for example, genes with low mean counts that DESeq2 had
# determined were unlikely to be called as differentially expressed. These
# genes are indicated by a value of "NA" in the "padj" column.
res <- res[ !is.na(res$padj), ]
# Select genes called as differentially expressed with the False Discovery Rate
# controlled at 10% - that is, at most 10% of the genes called as differentially
# expressed will be false positives.
resSig <- res[ res$padj < 0.1, ]
# Order the significant genes by p-value - i.e. by their likelihood of being
# differentially expressed.
head(resSig[ order(resSig$pvalue), ])
# Examine the most strongly down-regulated of the significant genes.
head(resSig[ order(resSig$log2FoldChange, -resSig$baseMean), ])
# Examine the most strongly up-regulated of the significant genes.
head(resSig[ order(-resSig$log2FoldChange, -resSig$baseMean), ])
# Select pasilla (which has FlyBase gene ID "FBgn0261552") from the results table. Is it differentially expressed (let's hope so!)?
resSig["FBgn0261552", ]
# Yes, its expression is down about 4-fold in the treated samples.
